match(n)
detach delete n

// Creazione del nodo Customer
CREATE (c:Customer {
    ID: 0,
    coord_x: 54.88135039273247,
    coord_y: 71.51893663724195,
    spending_mean: 62.262520726806166,
    spending_std: 31.131260363403083,
    transactions_per_day_mean: 2.1795327319875875
})

// Creazione del nodo Terminal
CREATE (t:Terminal {
    ID: 0,
    coord_x: 41.7022004702574,
    coord_y: 72.0324493442158
})

// Creazione della relazione TRANSACTION (direzionale)
CREATE (c)-[:TRANSACTION {
    ID: 0,
    duration_days: 0,
    duration_seconds: 31,
    dateAndTime: '2018-04-01 00:00:31',
    amount: 57.16,
    isFraud: false,
    fraudScenario: 0
}]->(t)







WITH date("2020-05-05") AS today
WITH today, date.truncate('month', today ) - duration('P1M') AS first_of_previous_month

MATCH (t:Terminal)

OPTIONAL MATCH (:Customer)-[tx_prev_month:Make_transaction]->(t)
  WHERE 
    tx_prev_month.tx_date_month = first_of_previous_month.month
    AND tx_prev_month.tx_date_year = first_of_previous_month.year

with today, t, max(tx_prev_month.tx_amount) * 1.2 as tx_amount_fraud_limit

OPTIONAL MATCH (:Customer)-[tx_current_month:Make_transaction]->(t)
  WHERE 
    tx_current_month.tx_date_month = today.month
    AND tx_current_month.tx_date_year = today.year

RETURN 
    t, 
    tx_current_month, 
    CASE 
        WHEN tx_amount_fraud_limit IS NULL THEN NULL
        WHEN tx_current_month.tx_amount > tx_amount_fraud_limit THEN true 
        ELSE false 
    END AS is_fraud






WITH date("2020-05-05") AS today
WITH today, date.truncate('month', today ) - duration('P1M') AS first_of_previous_month

MATCH (t:Terminal)

OPTIONAL MATCH (:Customer)-[tx_prev_month:Make_transaction]->(t)
  WHERE 
    tx_prev_month.tx_date_month = first_of_previous_month.month
    AND tx_prev_month.tx_date_year = first_of_previous_month.year

with today, t, max(tx_prev_month.tx_amount) * 1.2 as tx_amount_fraud_limit

OPTIONAL MATCH (:Customer)-[tx_current_month:Make_transaction]->(t)
  WHERE 
    tx_current_month.tx_date_month = today.month
    AND tx_current_month.tx_date_year = today.year

WITH 
    t, 
    tx_amount_fraud_limit,
    COLLECT(CASE 
        WHEN tx_current_month.tx_amount > tx_amount_fraud_limit THEN tx_current_month 
        ELSE NULL 
    END) AS fraud_txs_current_month

RETURN 
    t, 
    CASE 
        WHEN tx_amount_fraud_limit IS NULL THEN NULL
        ELSE fraud_txs_current_month
    END AS fraud_txs_current_month



---------------


WITH date("2020-05-05") AS today
WITH today, date.truncate('month', today ) - duration('P1M') AS first_of_previous_month

MATCH (t:Terminal)

OPTIONAL MATCH (:Customer)-[tx_prev_month:Make_transaction]->(t)
  WHERE 
    tx_prev_month.tx_date_month = first_of_previous_month.month
    AND tx_prev_month.tx_date_year = first_of_previous_month.year

with today, t, max(tx_prev_month.tx_amount) * 1.2 as tx_amount_fraud_limit

OPTIONAL MATCH (:Customer)-[tx_current_month:Make_transaction]->(t)
  WHERE 
    tx_current_month.tx_date_month = today.month
    AND tx_current_month.tx_date_year = today.year

WITH 
    t, 
    tx_amount_fraud_limit,
    COLLECT(CASE 
        WHEN tx_amount_fraud_limit IS NOT NULL AND tx_current_month.tx_amount > tx_amount_fraud_limit THEN tx_current_month 
        ELSE NULL 
    END) AS fraud_tx_current_month

RETURN 
    t, 
    CASE 
        WHEN tx_amount_fraud_limit IS NULL THEN NULL
        ELSE fraud_tx_current_month
    END AS fraud_tx_current_month






WITH date("2020-05-05") AS today
WITH today, date.truncate('month', today ) - duration('P1M') AS first_of_previous_month

MATCH (:Customer)-[tx_prev_month:Make_transaction]->(t:Terminal)
  WHERE 
    tx_prev_month.tx_date_month = first_of_previous_month.month
    AND tx_prev_month.tx_date_year = first_of_previous_month.year

with today, t, max(tx_prev_month.tx_amount) * 1.2 as tx_amount_fraud_limit

OPTIONAL MATCH (:Customer)-[tx_current_month:Make_transaction]->(t)
  WHERE 
    tx_current_month.tx_date_month = today.month
    AND tx_current_month.tx_date_year = today.year

RETURN 
    t,
    COLLECT( 
        CASE 
            WHEN tx_current_month.tx_amount > tx_amount_fraud_limit THEN tx_current_month 
            ELSE NULL 
        END 
    )AS fraud_txs_current_month




MATCH p = (u_1:Customer {customer_id:1})-[:Make_transaction*3]-(u_2:Customer)
WHERE all(node IN nodes(p)[1..-1] WHERE node:Terminal)
RETURN u_1, u_2


MATCH path = (u_i:Customer {customer_id: 1})-[:Make_transaction]*2-(u_f:Customer)
WHERE all(
    idx IN range(1, length(path) - 2)
    WHERE 
        (idx % 2 = 1 AND (nodes(path)[idx]):Terminal) 
        OR (idx % 2 = 0 AND (nodes(path)[idx]):Customer)
)
RETURN u_i, u_f


MATCH path = (u_i:Customer {customer_id: 1})-[:Make_transaction*2]-(u_f:Customer)
WHERE 
    u_i <> u_f AND
    all(idx IN range(1, length(path) - 2)
        WHERE 
            (
                idx % 2 = 0 AND (nodes(path)[idx]):Customer
                //AND 
                //(relationships(path)[idx]).direction = 'OUT'
            )
            OR 
            (
                idx % 2 = 1 AND (nodes(path)[idx]):Terminal 
                //AND 
                //(relationships(path)[idx]).direction = 'IN'
            )
    )
RETURN DISTINCT u_i.customer_id, u_f.customer_id

MATCH (u_i:Customer {customer_id: 1})-[:Make_transaction*2]-(u_f:Customer)
WHERE 
    u_i.customer_id <> u_f.customer_id
RETURN DISTINCT u_i.customer_id, u_f.customer_id


MATCH (u_i:Customer {customer_id: 1})
CALL apoc.path.subgraphNodes(u_i, {
  relationshipFilter: 'Make_transaction',
  labelFilter: 'Customer',
  labelFilter: "Terminal|Customer",
  maxLevel: 2
}) YIELD node AS u_f
WHERE u_i <> u_f
RETURN DISTINCT u_i.customer_id, u_f.customer_id




MATCH (u_i:Customer {customer_id: 1})
CALL apoc.path.subgraphNodes(u_i, {
  relationshipFilter: 'Make_transaction',
  labelFilter: 'Customer',
  maxLevel: 2
}) YIELD node AS u_f
WHERE u_i <> u_f
WITH DISTINCT u_i, u_f
MATCH path = (u_i)-[:Make_transaction*2]->(u_f)
RETURN u_i.customer_id, u_f.customer_id


WITH 2 * 2 as k
MATCH (start:Customer {customer_id: 1})
CALL apoc.path.expandConfig(start, {
  relationshipFilter: 'Make_transaction',
  labelFilter: 'Terminal|Customer',
  maxLevel:  k
}) YIELD path

WITH path
WHERE length(path) = k
RETURN nodes(path)[0] AS firstCustomer, nodes(path)[-1] AS lastCustomer



WITH 2 as k
MATCH (start:Customer {customer_id: 1})
CALL apoc.path.expandConfig(start, {
    relationshipFilter: 'Make_transaction',
    labelFilter: 'Terminal|Customer',
    maxLevel: k
}) YIELD path

WITH path
WHERE length(path) = k
RETURN DISTINCT nodes(path)[-1].customer_id AS CO_Customer


WITH 2 AS k
MATCH (start:Customer {customer_id: 1})
CALL apoc.path.expandConfig(start, {
    relationshipFilter: 'Make_transaction',
    labelFilter: 'Terminal|Customer',
    maxLevel: k,
    uniqueness: 'NODE_GLOBAL'  // Questo garantisce che ogni nodo sia unico
}) YIELD path

WITH path
WHERE length(path) = k
RETURN DISTINCT nodes(path)[-1].customer_id AS CO_Customer








WITH 4 AS k
MATCH (start:Customer {customer_id: 1})
CALL apoc.path.expandConfig(start, {
    relationshipFilter: 'Make_transaction',
    labelFilter: 'Terminal|Customer',
    maxLevel: k,
    uniqueness: 'NODE_GLOBAL'
}) YIELD path

WITH path
WHERE length(path) = k
RETURN nodes(path)[-1].customer_id AS CO_Customer




    
    CALL apoc.trigger.add(
  'Make_transaction_schema',
  '
  UNWIND $createdRelationships AS r
  MATCH (startNode)-[r:Make_transaction]->(endNode)
  WHERE NOT (startNode:Customer AND endNode:Terminal)
  CALL apoc.util.validate(true, "Make_transaction relationship not valid: check relationship start or end node", [])
  RETURN r
  ',
  {phase:'before'}
)


CALL apoc.periodic.iterate(
    'MATCH (c:Customer)-[transaction:Make_transaction]->(t:Terminal) 
    RETURN transaction',
    'SET transaction.tx_day_period=1,
         transaction.tx_products_type=1,
         transaction.tx_security_feeling=1',
    {{batchSize: {config.lines_per_commit}, parallel: {config.parallel_loading}}}
)

CALL apoc.periodic.iterate(
    'MATCH (c:Customer)-[transaction:Make_transaction]->(t:Terminal) 
    RETURN transaction',
    'SET transaction.tx_day_period = CASE rand() * 4 
                                         WHEN 0 THEN "morning" 
                                         WHEN 1 THEN "afternoon" 
                                         WHEN 2 THEN "evening" 
                                         ELSE "night" 
                                     END,
         transaction.tx_products_type = CASE rand() * 5 
                                            WHEN 0 THEN "high-tech" 
                                            WHEN 1 THEN "food" 
                                            WHEN 2 THEN "clothing" 
                                            WHEN 3 THEN "consumable" 
                                            ELSE "other" 
                                        END,
         transaction.tx_security_feeling = toInteger(rand() * 5) + 1',
    {batchSize: {config.lines_per_commit}, parallel: {config.parallel_loading}}
)



MATCH (c1:Customer)-[tx1:Make_transaction]->(t:Terminal) 
WITH c1, t, COUNT(tx1) AS count_tx1 
WHERE count_tx1 > 3  

MATCH (c2:Customer)-[tx2:Make_transaction]->(t:Terminal) 
WITH c1, c2, t, count_tx1, COUNT(tx2) AS count_tx2 
WHERE count_tx2 > 3  

WITH c1, c2, t, count_tx1, count_tx2 
where c1 <> c2 

return c1, c2, t, count_tx1, count_tx2 
order by c1, c2


cambia solo <> con <

MATCH (c1:Customer)-[tx1:Make_transaction]->(t:Terminal) 
WITH c1, t, COUNT(tx1) AS count_tx1 
WHERE count_tx1 > 3  

MATCH (c2:Customer)-[tx2:Make_transaction]->(t:Terminal) 
WITH c1, c2, t, count_tx1, COUNT(tx2) AS count_tx2 
WHERE count_tx2 > 3  

WITH c1, c2, t, count_tx1, count_tx2 
where c1 < c2 

return c1, c2, t, count_tx1, count_tx2 
order by c1, c2











MATCH (c1:Customer)-[tx1:Make_transaction]->(t:Terminal) 
WITH c1, t, COUNT(tx1) AS count_tx1, avg(tx1.tx_security_feeling) as avg_tx1_security_feeling
WHERE count_tx1 > 3  

MATCH (c2:Customer)-[tx2:Make_transaction]->(t:Terminal) 
WITH c1, c2, t, avg_tx1_security_feeling, COUNT(tx2) AS count_tx2, avg(tx2.tx_security_feeling) as avg_tx2_security_feeling
WHERE count_tx2 > 3 and c1 < c2 and (abs(avg_tx1_security_feeling - avg_tx2_security_feeling) < 1)

return c1, c2







match (:Customer)-[tx:Make_transaction]-(:Terminal) return tx.tx_day_period, count(*)


WITH date("{day_under_analesis}") AS today
WITH today, date.truncate('month', today ) - duration('P1M') AS first_of_previous_month

MATCH (:Customer)-[tx_prev_month:Make_transaction]->(t:Terminal)
WHERE 
    tx_prev_month.tx_date_month = first_of_previous_month.month
    AND tx_prev_month.tx_date_year = first_of_previous_month.year

with today, t, max(tx_prev_month.tx_amount) * 1.2 as tx_amount_fraud_limit

OPTIONAL MATCH (:Customer)-[tx_current_month:Make_transaction]->(t)
WHERE 
    tx_current_month.tx_date_month = today.month
    AND tx_current_month.tx_date_year = today.year

RETURN 
    t,
    COLLECT( 
        CASE 
            WHEN tx_current_month.tx_amount > tx_amount_fraud_limit THEN tx_current_month 
            ELSE NULL 
        END 
    )AS fraud_txs_current_month


MATCH (:Customer)-[tx:Make_transaction]->(t:Terminal)
WITH COLLECT(DISTINCT {year: tx.tx_date_year, month: tx.tx_date_month}) AS date_pairs
UNWIND date_pairs AS date_pair
MATCH (c:Customer)-[tx:Make_transaction]->(t:Terminal)
WHERE tx.tx_date_year = date_pair.year AND tx.tx_date_month = date_pair.month
WITH date_pair, count(tx) AS transaction_count
RETURN date_pair.year AS year, date_pair.month AS month, transaction_count
ORDER BY year, month




MATCH (:Customer)-[tx:Make_transaction]->(t:Terminal) 
WITH DISTINCT tx.tx_date_year AS year, tx.tx_date_month AS month  

MATCH (:Customer)-[tx_prev_month:Make_transaction]->(t:Terminal) 
WHERE 
  tx_prev_month.tx_date_year = (date({year: year, month: month, day: 1}) - duration({months: 1})).year AND 
  tx_prev_month.tx_date_month = (date({year: year, month: month, day: 1}) - duration({months: 1})).month  

RETURN tx_prev_month 



MATCH (:Customer)-[tx:Make_transaction]->(t:Terminal) 
WITH DISTINCT tx.tx_date_year AS year, tx.tx_date_month AS month  

MATCH (:Customer)-[tx_prev_month:Make_transaction]->(t:Terminal) 
WHERE 
  tx_prev_month.tx_date_year = (date({year: year, month: month, day: 1}) - duration({months: 1})).year AND 
  tx_prev_month.tx_date_month = (date({year: year, month: month, day: 1}) - duration({months: 1})).month  

RETURN year, month, max(tx_prev_month.tx_amount) * 1.2 as tx_amount_fraud_limit





MATCH (:Customer)-[tx:Make_transaction]->(t:Terminal) 
WITH DISTINCT tx.tx_date_year AS year, tx.tx_date_month AS month  

MATCH (:Customer)-[tx_prev_month:Make_transaction]->(t:Terminal) 
WHERE 
  tx_prev_month.tx_date_year = (date({year: year, month: month, day: 1}) - duration({months: 1})).year AND 
  tx_prev_month.tx_date_month = (date({year: year, month: month, day: 1}) - duration({months: 1})).month  

WITH year, month, max(tx_prev_month.tx_amount) * 1.2 as tx_amount_fraud_limit

MATCH (:Customer)-[tx_current_month:Make_transaction]->(t)
WHERE 
    tx_current_month.tx_date_month = month
    AND tx_current_month.tx_date_year = year

RETURN 
    year, 
    month, 
    count(tx_current_month), 
    count( 
        CASE 
            WHEN tx_current_month.tx_amount > tx_amount_fraud_limit THEN 1 
            ELSE NULL 
        END 
    )AS fraud_txs_current_month












MATCH (:Customer)-[tx:Make_transaction]->(t:Terminal) 
WITH DISTINCT tx.tx_date_year AS year, tx.tx_date_month AS month  

MATCH (:Customer)-[tx_prev_month:Make_transaction]->(t:Terminal) 
WHERE 
  tx_prev_month.tx_date_year = (date({year: year, month: month, day: 1}) - duration({months: 1})).year AND 
  tx_prev_month.tx_date_month = (date({year: year, month: month, day: 1}) - duration({months: 1})).month  

WITH year, month, max(tx_prev_month.tx_amount) * 1.2 as tx_amount_fraud_limit

MATCH (:Customer)-[tx_current_month:Make_transaction]->(t)
WHERE 
    tx_current_month.tx_date_month = month
    AND tx_current_month.tx_date_year = year

WITH 
    year, 
    month,
    tx_current_month.tx_day_period as day_period,
    count(tx_current_month) as tx_count, 
    count( 
        CASE 
            WHEN tx_current_month.tx_amount > tx_amount_fraud_limit THEN 1 
            ELSE NULL 
        END
    )AS tx_fraud_count

RETURN day_period, sum(tx_count) AS total_transactions, avg(tx_fraud_count) AS monthly_avg_fraud_transactions 
  





WITH date('2023-01' + '-01') AS startDate, 
     date('2023-03' + '-01') AS endDate
MATCH (:Customer)-[tx:Make_transaction]->(t:Terminal)
WHERE 
    (startDate IS NULL OR date({year: tx.tx_date_year, month: tx.tx_date_month}) >= startDate)
    AND (endDate IS NULL OR date({year: tx.tx_date_year, month: tx.tx_date_month}) <= endDate)
WITH DISTINCT tx.tx_date_year AS year, tx.tx_date_month AS month

MATCH (:Customer)-[tx_prev_month:Make_transaction]->(t:Terminal) 
WHERE 
  tx_prev_month.tx_date_year = (date({year: year, month: month, day: 1}) - duration({months: 1})).year AND 
  tx_prev_month.tx_date_month = (date({year: year, month: month, day: 1}) - duration({months: 1})).month  

WITH year, month, max(tx_prev_month.tx_amount) * 1.2 as tx_amount_fraud_limit

MATCH (:Customer)-[tx_current_month:Make_transaction]->(t)
WHERE 
    tx_current_month.tx_date_month = month
    AND tx_current_month.tx_date_year = year

WITH 
    year, 
    month,
    tx_current_month.tx_day_period as day_period,
    count(tx_current_month) as tx_count, 
    count( 
        CASE 
            WHEN tx_current_month.tx_amount > tx_amount_fraud_limit THEN 1 
            ELSE NULL 
        END
    )AS tx_fraud_count

RETURN day_period, sum(tx_count) AS total_transactions, avg(tx_fraud_count) AS monthly_avg_fraud_transactions 
  